Celem tej pracy jest zaprojektowanie i implementacja oprogramowania do przetwarzania obrazów z funkcjonalnym interfejsem graficznym.

Zakres pracy objął analizę istniejących rozwiązań na podstawie której stwierdzono, że nie ma aktualnego i gotowego produktu który realizuje dokładnie założenie zastąpienia programistycznego podejścia do obsługi bibliotek przetwarzania obrazów. 
Jest wiele rozwiązań które realizuje część biblioteki lub jej obsługa nie pozwala na przetwarzanie obrazów w niedestrukcyjny sposób bez dodatkowego wysiłku od użytkownika jak używanie warstw czy inkrementalnych zapisów. 

Jako platformę wybrano komputer osobisty z powodu znaczącej mocy obliczeniowej, dostępu do dużej ilości pamięci RAM oraz do operacji procesorów x86 z których biblioteki do przetwarzania obrazów czasem korzystają do akceleracji obliczeń \cite{x86opencv}. 
Jako docelowy system operacyjny wybrano Microsoft Windows 11 ponieważ jest to system używany przez autora tej pracy. 
Do tworzenia aplikacji skorzystano z języka C\# oraz Windows Presentation Framework. 

W ramach czasu, który został poświecony na niniejszy projekt zakres możliwości ograniczono do prostych operacji przetwarzania obrazów bez uwzględniania wideo oraz wszelkiego rodzaju danych oprócz samych obrazów. 

Pomysł na ten projekt powstał dzięki doświadczeniu autora pracy w używaniu różnych systemów opartych o edytory typu węzłowego jak Adobe Substance Designer, edytor Blueprintów w Unreal Engine oraz edytor shaderów czy geometry nodes w Blenderze. 
Ten typ interfejsu pozwala na interakcję użytkownika z wizualnym przedstawieniem jakichś metod, funkcji czy bloków logicznych pozwalających na przesyłanie wartości w podobny sposób jak można robić to w kodzie, ale zdecydowanie bardziej przystępne dla osób które nie mają odpowiedniego doświadczenia w programowaniu.

Dużą zaletą tego podejścia w porównaniu do edycji w programach posługujących się warstwami jest to, że możemy wrócić w każdym momencie do dowolnej poprzedniej operacji. 
Użytkownik może zmienić wartość operacji, zmienić ich kolejność i w żadnym momencie nie traci wyniku operacji, ponieważ każda zmiana powoduje obliczenie rezultatu jeszcze raz. 
Przeliczenie całego drzewa na nowym obrazie wejściowym i otrzymanie wyniku którego się spodziewamy to zmiana jednego parametru.